// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: EntryProtocol.proto

package dsgpb

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

//*打散后的事件类型，主要用于标识事务的开始，变更数据，结束*
type EntryType int32

const (
	EntryType_TRANSACTIONBEGIN EntryType = 1
	EntryType_TABLEINFO        EntryType = 2
	EntryType_ROWDATA          EntryType = 3
	EntryType_ROWDATALIST      EntryType = 4
	EntryType_TRANSACTIONEND   EntryType = 5
	//* 心跳类型，内部使用，外部暂不可见，可忽略 *
	EntryType_HEARTBEAT EntryType = 6
)

var EntryType_name = map[int32]string{
	1: "TRANSACTIONBEGIN",
	2: "TABLEINFO",
	3: "ROWDATA",
	4: "ROWDATALIST",
	5: "TRANSACTIONEND",
	6: "HEARTBEAT",
}

var EntryType_value = map[string]int32{
	"TRANSACTIONBEGIN": 1,
	"TABLEINFO":        2,
	"ROWDATA":          3,
	"ROWDATALIST":      4,
	"TRANSACTIONEND":   5,
	"HEARTBEAT":        6,
}

func (x EntryType) Enum() *EntryType {
	p := new(EntryType)
	*p = x
	return p
}

func (x EntryType) String() string {
	return proto.EnumName(EntryType_name, int32(x))
}

func (x *EntryType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntryType_value, data, "EntryType")
	if err != nil {
		return err
	}
	*x = EntryType(value)
	return nil
}

func (EntryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{0}
}

//* 事件类型 *
type EventType int32

const (
	EventType_FULLINSERT EventType = 1
	EventType_INSERT     EventType = 2
	EventType_UPDATE     EventType = 3
	EventType_DELETE     EventType = 4
	EventType_FULLDELETE EventType = 5
	EventType_CREATE     EventType = 6
	EventType_ALTER      EventType = 7
	EventType_ERASE      EventType = 8
	EventType_QUERY      EventType = 9
	EventType_DROP       EventType = 10
	EventType_TRUNCATE   EventType = 11
	EventType_RENAME     EventType = 12
	//*CREATE INDEX*
	EventType_CINDEX    EventType = 13
	EventType_DINDEX    EventType = 14
	EventType_TABLE_END EventType = 15
	EventType_FULL_DOWN EventType = 16
)

var EventType_name = map[int32]string{
	1:  "FULLINSERT",
	2:  "INSERT",
	3:  "UPDATE",
	4:  "DELETE",
	5:  "FULLDELETE",
	6:  "CREATE",
	7:  "ALTER",
	8:  "ERASE",
	9:  "QUERY",
	10: "DROP",
	11: "TRUNCATE",
	12: "RENAME",
	13: "CINDEX",
	14: "DINDEX",
	15: "TABLE_END",
	16: "FULL_DOWN",
}

var EventType_value = map[string]int32{
	"FULLINSERT": 1,
	"INSERT":     2,
	"UPDATE":     3,
	"DELETE":     4,
	"FULLDELETE": 5,
	"CREATE":     6,
	"ALTER":      7,
	"ERASE":      8,
	"QUERY":      9,
	"DROP":       10,
	"TRUNCATE":   11,
	"RENAME":     12,
	"CINDEX":     13,
	"DINDEX":     14,
	"TABLE_END":  15,
	"FULL_DOWN":  16,
}

func (x EventType) Enum() *EventType {
	p := new(EventType)
	*p = x
	return p
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}

func (x *EventType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EventType_value, data, "EventType")
	if err != nil {
		return err
	}
	*x = EventType(value)
	return nil
}

func (EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{1}
}

//*数据库/接口类型*
type DBType int32

const (
	DBType_ORACLE    DBType = 1
	DBType_MYSQL     DBType = 2
	DBType_PGSQL     DBType = 3
	DBType_OB_MYSQL  DBType = 4
	DBType_OB_ORACLE DBType = 5
	DBType_MPP       DBType = 6
	DBType_HTTP      DBType = 7
	DBType_FTP       DBType = 8
)

var DBType_name = map[int32]string{
	1: "ORACLE",
	2: "MYSQL",
	3: "PGSQL",
	4: "OB_MYSQL",
	5: "OB_ORACLE",
	6: "MPP",
	7: "HTTP",
	8: "FTP",
}

var DBType_value = map[string]int32{
	"ORACLE":    1,
	"MYSQL":     2,
	"PGSQL":     3,
	"OB_MYSQL":  4,
	"OB_ORACLE": 5,
	"MPP":       6,
	"HTTP":      7,
	"FTP":       8,
}

func (x DBType) Enum() *DBType {
	p := new(DBType)
	*p = x
	return p
}

func (x DBType) String() string {
	return proto.EnumName(DBType_name, int32(x))
}

func (x *DBType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DBType_value, data, "DBType")
	if err != nil {
		return err
	}
	*x = DBType(value)
	return nil
}

func (DBType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{2}
}

//***************************************************************
// message model
//如果要在Enum中新增类型，确保以前的类型的下标值不变.
//**************************************************************
type Entry struct {
	UserID *string `protobuf:"bytes,1,opt,name=userID" json:"userID,omitempty"`
	FlowID *string `protobuf:"bytes,2,opt,name=flowID" json:"flowID,omitempty"`
	//PB数据的状态，如果=false，直接读取 errorMsg
	StatFlag *bool `protobuf:"varint,3,opt,name=statFlag" json:"statFlag,omitempty"`
	//批次ID
	BatchID *string `protobuf:"bytes,4,opt,name=batchID" json:"batchID,omitempty"`
	//条数
	BatchCountNo *int32 `protobuf:"varint,5,opt,name=batchCountNo" json:"batchCountNo,omitempty"`
	//*协议头部信息*
	Header *Header `protobuf:"bytes,6,opt,name=header" json:"header,omitempty"`
	//*打散后的事件类型*
	EntryType *EntryType `protobuf:"varint,7,opt,name=entryType,enum=dsgpb.EntryType,def=3" json:"entryType,omitempty"`
	//*传输的二进制数组*
	StoreValue           []byte       `protobuf:"bytes,8,opt,name=storeValue" json:"storeValue,omitempty"`
	ErrorMsg             *string      `protobuf:"bytes,9,opt,name=errorMsg" json:"errorMsg,omitempty"`
	TheLastNum           *int32       `protobuf:"varint,10,opt,name=theLastNum" json:"theLastNum,omitempty"`
	ThisRowNum           *int32       `protobuf:"varint,11,opt,name=thisRowNum" json:"thisRowNum,omitempty"`
	AdditionalWeight     *RowDataList `protobuf:"bytes,12,opt,name=additionalWeight" json:"additionalWeight,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Entry) Reset()         { *m = Entry{} }
func (m *Entry) String() string { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()    {}
func (*Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{0}
}
func (m *Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entry.Merge(m, src)
}
func (m *Entry) XXX_Size() int {
	return m.Size()
}
func (m *Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_Entry proto.InternalMessageInfo

const Default_Entry_EntryType EntryType = EntryType_ROWDATA

func (m *Entry) GetUserID() string {
	if m != nil && m.UserID != nil {
		return *m.UserID
	}
	return ""
}

func (m *Entry) GetFlowID() string {
	if m != nil && m.FlowID != nil {
		return *m.FlowID
	}
	return ""
}

func (m *Entry) GetStatFlag() bool {
	if m != nil && m.StatFlag != nil {
		return *m.StatFlag
	}
	return false
}

func (m *Entry) GetBatchID() string {
	if m != nil && m.BatchID != nil {
		return *m.BatchID
	}
	return ""
}

func (m *Entry) GetBatchCountNo() int32 {
	if m != nil && m.BatchCountNo != nil {
		return *m.BatchCountNo
	}
	return 0
}

func (m *Entry) GetHeader() *Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Entry) GetEntryType() EntryType {
	if m != nil && m.EntryType != nil {
		return *m.EntryType
	}
	return Default_Entry_EntryType
}

func (m *Entry) GetStoreValue() []byte {
	if m != nil {
		return m.StoreValue
	}
	return nil
}

func (m *Entry) GetErrorMsg() string {
	if m != nil && m.ErrorMsg != nil {
		return *m.ErrorMsg
	}
	return ""
}

func (m *Entry) GetTheLastNum() int32 {
	if m != nil && m.TheLastNum != nil {
		return *m.TheLastNum
	}
	return 0
}

func (m *Entry) GetThisRowNum() int32 {
	if m != nil && m.ThisRowNum != nil {
		return *m.ThisRowNum
	}
	return 0
}

func (m *Entry) GetAdditionalWeight() *RowDataList {
	if m != nil {
		return m.AdditionalWeight
	}
	return nil
}

//*message Header*
type Header struct {
	//* 变更数据的schemaname*
	SchemaName *string `protobuf:"bytes,1,opt,name=schemaName" json:"schemaName,omitempty"`
	//*变更数据的tablename*
	TableName *string `protobuf:"bytes,2,opt,name=tableName" json:"tableName,omitempty"`
	//*数据变更类型*
	EventType            *EventType `protobuf:"varint,3,opt,name=eventType,enum=dsgpb.EventType,def=3" json:"eventType,omitempty"`
	FileNo               *string    `protobuf:"bytes,4,opt,name=fileNo" json:"fileNo,omitempty"`
	ScnInfo              *string    `protobuf:"bytes,5,opt,name=scnInfo" json:"scnInfo,omitempty"`
	ObjnInfo             *string    `protobuf:"bytes,6,opt,name=objnInfo" json:"objnInfo,omitempty"`
	OperType             *string    `protobuf:"bytes,7,opt,name=operType" json:"operType,omitempty"`
	RowsNum              *int64     `protobuf:"varint,8,opt,name=rowsNum" json:"rowsNum,omitempty"`
	ColsNum              *int64     `protobuf:"varint,9,opt,name=colsNum" json:"colsNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{1}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

const Default_Header_EventType EventType = EventType_UPDATE

func (m *Header) GetSchemaName() string {
	if m != nil && m.SchemaName != nil {
		return *m.SchemaName
	}
	return ""
}

func (m *Header) GetTableName() string {
	if m != nil && m.TableName != nil {
		return *m.TableName
	}
	return ""
}

func (m *Header) GetEventType() EventType {
	if m != nil && m.EventType != nil {
		return *m.EventType
	}
	return Default_Header_EventType
}

func (m *Header) GetFileNo() string {
	if m != nil && m.FileNo != nil {
		return *m.FileNo
	}
	return ""
}

func (m *Header) GetScnInfo() string {
	if m != nil && m.ScnInfo != nil {
		return *m.ScnInfo
	}
	return ""
}

func (m *Header) GetObjnInfo() string {
	if m != nil && m.ObjnInfo != nil {
		return *m.ObjnInfo
	}
	return ""
}

func (m *Header) GetOperType() string {
	if m != nil && m.OperType != nil {
		return *m.OperType
	}
	return ""
}

func (m *Header) GetRowsNum() int64 {
	if m != nil && m.RowsNum != nil {
		return *m.RowsNum
	}
	return 0
}

func (m *Header) GetColsNum() int64 {
	if m != nil && m.ColsNum != nil {
		return *m.ColsNum
	}
	return 0
}

//*每个字段的数据结构*
type Column struct {
	ColNo   *int32  `protobuf:"varint,1,opt,name=colNo" json:"colNo,omitempty"`
	ColType *string `protobuf:"bytes,2,opt,name=colType" json:"colType,omitempty"`
	//*字段名称(忽略大小写)，在mysql中是没有的*
	ColName *string `protobuf:"bytes,3,opt,name=colName" json:"colName,omitempty"`
	//* 字段标识 *
	ColFlags *int32 `protobuf:"varint,4,opt,name=colFlags" json:"colFlags,omitempty"`
	//* 数据的长度 *
	ColValueLen          *int32   `protobuf:"varint,5,opt,name=colValueLen" json:"colValueLen,omitempty"`
	ColValue             *string  `protobuf:"bytes,6,opt,name=colValue" json:"colValue,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Column) Reset()         { *m = Column{} }
func (m *Column) String() string { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()    {}
func (*Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{2}
}
func (m *Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Column.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Column.Merge(m, src)
}
func (m *Column) XXX_Size() int {
	return m.Size()
}
func (m *Column) XXX_DiscardUnknown() {
	xxx_messageInfo_Column.DiscardUnknown(m)
}

var xxx_messageInfo_Column proto.InternalMessageInfo

func (m *Column) GetColNo() int32 {
	if m != nil && m.ColNo != nil {
		return *m.ColNo
	}
	return 0
}

func (m *Column) GetColType() string {
	if m != nil && m.ColType != nil {
		return *m.ColType
	}
	return ""
}

func (m *Column) GetColName() string {
	if m != nil && m.ColName != nil {
		return *m.ColName
	}
	return ""
}

func (m *Column) GetColFlags() int32 {
	if m != nil && m.ColFlags != nil {
		return *m.ColFlags
	}
	return 0
}

func (m *Column) GetColValueLen() int32 {
	if m != nil && m.ColValueLen != nil {
		return *m.ColValueLen
	}
	return 0
}

func (m *Column) GetColValue() string {
	if m != nil && m.ColValue != nil {
		return *m.ColValue
	}
	return ""
}

type RowData struct {
	ColValueLens *int32 `protobuf:"varint,1,opt,name=colValueLens" json:"colValueLens,omitempty"`
	//* 字段信息，增量数据(修改前,删除前) *
	Columns              []*Column `protobuf:"bytes,2,rep,name=columns" json:"columns,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RowData) Reset()         { *m = RowData{} }
func (m *RowData) String() string { return proto.CompactTextString(m) }
func (*RowData) ProtoMessage()    {}
func (*RowData) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{3}
}
func (m *RowData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RowData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RowData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowData.Merge(m, src)
}
func (m *RowData) XXX_Size() int {
	return m.Size()
}
func (m *RowData) XXX_DiscardUnknown() {
	xxx_messageInfo_RowData.DiscardUnknown(m)
}

var xxx_messageInfo_RowData proto.InternalMessageInfo

func (m *RowData) GetColValueLens() int32 {
	if m != nil && m.ColValueLens != nil {
		return *m.ColValueLens
	}
	return 0
}

func (m *RowData) GetColumns() []*Column {
	if m != nil {
		return m.Columns
	}
	return nil
}

//*message row 每行变更数据的数据结构*
type RowDataList struct {
	//* 一次数据库变更可能存在多行  *
	RowDatas             []*RowData `protobuf:"bytes,1,rep,name=rowDatas" json:"rowDatas,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RowDataList) Reset()         { *m = RowDataList{} }
func (m *RowDataList) String() string { return proto.CompactTextString(m) }
func (*RowDataList) ProtoMessage()    {}
func (*RowDataList) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{4}
}
func (m *RowDataList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowDataList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RowDataList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RowDataList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowDataList.Merge(m, src)
}
func (m *RowDataList) XXX_Size() int {
	return m.Size()
}
func (m *RowDataList) XXX_DiscardUnknown() {
	xxx_messageInfo_RowDataList.DiscardUnknown(m)
}

var xxx_messageInfo_RowDataList proto.InternalMessageInfo

func (m *RowDataList) GetRowDatas() []*RowData {
	if m != nil {
		return m.RowDatas
	}
	return nil
}

//*开始事务的一些信息*
type TransactionBegin struct {
	//*已废弃，请使用header里的executeTime*
	ExecuteTime *int64 `protobuf:"varint,1,opt,name=executeTime" json:"executeTime,omitempty"`
	//*已废弃，Begin里不提供事务id*
	TransactionId *string `protobuf:"bytes,2,opt,name=transactionId" json:"transactionId,omitempty"`
	//*预留扩展*
	Props []*Pair `protobuf:"bytes,3,rep,name=props" json:"props,omitempty"`
	//*执行的thread Id*
	ThreadId             *int64   `protobuf:"varint,4,opt,name=threadId" json:"threadId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransactionBegin) Reset()         { *m = TransactionBegin{} }
func (m *TransactionBegin) String() string { return proto.CompactTextString(m) }
func (*TransactionBegin) ProtoMessage()    {}
func (*TransactionBegin) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{5}
}
func (m *TransactionBegin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionBegin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionBegin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionBegin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionBegin.Merge(m, src)
}
func (m *TransactionBegin) XXX_Size() int {
	return m.Size()
}
func (m *TransactionBegin) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionBegin.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionBegin proto.InternalMessageInfo

func (m *TransactionBegin) GetExecuteTime() int64 {
	if m != nil && m.ExecuteTime != nil {
		return *m.ExecuteTime
	}
	return 0
}

func (m *TransactionBegin) GetTransactionId() string {
	if m != nil && m.TransactionId != nil {
		return *m.TransactionId
	}
	return ""
}

func (m *TransactionBegin) GetProps() []*Pair {
	if m != nil {
		return m.Props
	}
	return nil
}

func (m *TransactionBegin) GetThreadId() int64 {
	if m != nil && m.ThreadId != nil {
		return *m.ThreadId
	}
	return 0
}

type TableInfo struct {
	//*协议的版本号*
	Version *int32 `protobuf:"varint,1,opt,name=version,def=1" json:"version,omitempty"`
	//* 变更数据的来源*
	SourceType           *DBType        `protobuf:"varint,2,opt,name=sourceType,enum=dsgpb.DBType,def=2" json:"sourceType,omitempty"`
	SchemaName           *string        `protobuf:"bytes,3,opt,name=schemaName" json:"schemaName,omitempty"`
	TableName            *string        `protobuf:"bytes,4,opt,name=tableName" json:"tableName,omitempty"`
	TableID              *string        `protobuf:"bytes,5,opt,name=tableID" json:"tableID,omitempty"`
	ObjnNo               *int32         `protobuf:"varint,6,opt,name=objnNo" json:"objnNo,omitempty"`
	TableCharacterSet    *string        `protobuf:"bytes,7,opt,name=tableCharacterSet" json:"tableCharacterSet,omitempty"`
	CreateTime           *string        `protobuf:"bytes,8,opt,name=createTime" json:"createTime,omitempty"`
	TableDescription     *string        `protobuf:"bytes,9,opt,name=tableDescription" json:"tableDescription,omitempty"`
	PrimaryInfos         []*PrimaryInfo `protobuf:"bytes,10,rep,name=primaryInfos" json:"primaryInfos,omitempty"`
	ColumnInfos          []*ColumnInfo  `protobuf:"bytes,11,rep,name=columnInfos" json:"columnInfos,omitempty"`
	IndexInfos           []*IndexInfo   `protobuf:"bytes,12,rep,name=indexInfos" json:"indexInfos,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TableInfo) Reset()         { *m = TableInfo{} }
func (m *TableInfo) String() string { return proto.CompactTextString(m) }
func (*TableInfo) ProtoMessage()    {}
func (*TableInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{6}
}
func (m *TableInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableInfo.Merge(m, src)
}
func (m *TableInfo) XXX_Size() int {
	return m.Size()
}
func (m *TableInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TableInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TableInfo proto.InternalMessageInfo

const Default_TableInfo_Version int32 = 1
const Default_TableInfo_SourceType DBType = DBType_MYSQL

func (m *TableInfo) GetVersion() int32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return Default_TableInfo_Version
}

func (m *TableInfo) GetSourceType() DBType {
	if m != nil && m.SourceType != nil {
		return *m.SourceType
	}
	return Default_TableInfo_SourceType
}

func (m *TableInfo) GetSchemaName() string {
	if m != nil && m.SchemaName != nil {
		return *m.SchemaName
	}
	return ""
}

func (m *TableInfo) GetTableName() string {
	if m != nil && m.TableName != nil {
		return *m.TableName
	}
	return ""
}

func (m *TableInfo) GetTableID() string {
	if m != nil && m.TableID != nil {
		return *m.TableID
	}
	return ""
}

func (m *TableInfo) GetObjnNo() int32 {
	if m != nil && m.ObjnNo != nil {
		return *m.ObjnNo
	}
	return 0
}

func (m *TableInfo) GetTableCharacterSet() string {
	if m != nil && m.TableCharacterSet != nil {
		return *m.TableCharacterSet
	}
	return ""
}

func (m *TableInfo) GetCreateTime() string {
	if m != nil && m.CreateTime != nil {
		return *m.CreateTime
	}
	return ""
}

func (m *TableInfo) GetTableDescription() string {
	if m != nil && m.TableDescription != nil {
		return *m.TableDescription
	}
	return ""
}

func (m *TableInfo) GetPrimaryInfos() []*PrimaryInfo {
	if m != nil {
		return m.PrimaryInfos
	}
	return nil
}

func (m *TableInfo) GetColumnInfos() []*ColumnInfo {
	if m != nil {
		return m.ColumnInfos
	}
	return nil
}

func (m *TableInfo) GetIndexInfos() []*IndexInfo {
	if m != nil {
		return m.IndexInfos
	}
	return nil
}

type PrimaryInfo struct {
	ColumnNo             *string  `protobuf:"bytes,1,opt,name=columnNo" json:"columnNo,omitempty"`
	ColumnName           *string  `protobuf:"bytes,2,opt,name=columnName" json:"columnName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PrimaryInfo) Reset()         { *m = PrimaryInfo{} }
func (m *PrimaryInfo) String() string { return proto.CompactTextString(m) }
func (*PrimaryInfo) ProtoMessage()    {}
func (*PrimaryInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{7}
}
func (m *PrimaryInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrimaryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrimaryInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrimaryInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrimaryInfo.Merge(m, src)
}
func (m *PrimaryInfo) XXX_Size() int {
	return m.Size()
}
func (m *PrimaryInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PrimaryInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PrimaryInfo proto.InternalMessageInfo

func (m *PrimaryInfo) GetColumnNo() string {
	if m != nil && m.ColumnNo != nil {
		return *m.ColumnNo
	}
	return ""
}

func (m *PrimaryInfo) GetColumnName() string {
	if m != nil && m.ColumnName != nil {
		return *m.ColumnName
	}
	return ""
}

type ColumnInfo struct {
	//列名称
	ColName *string `protobuf:"bytes,1,opt,name=colName" json:"colName,omitempty"`
	//列长度
	ColLen *string `protobuf:"bytes,2,opt,name=colLen" json:"colLen,omitempty"`
	//列的精度
	DataPrecision *string `protobuf:"bytes,3,opt,name=data_precision,json=dataPrecision" json:"data_precision,omitempty"`
	//数据类型
	DataType *string `protobuf:"bytes,4,opt,name=dataType" json:"dataType,omitempty"`
	//数据对应的Java类型
	ColJavaType *string `protobuf:"bytes,5,opt,name=colJavaType" json:"colJavaType,omitempty"`
	//列类型定义
	ColumnType  *string `protobuf:"bytes,6,opt,name=columnType" json:"columnType,omitempty"`
	GeneralType []byte  `protobuf:"bytes,7,opt,name=generalType" json:"generalType,omitempty"`
	//列的序列
	OrderNo *int32 `protobuf:"varint,8,opt,name=orderNo" json:"orderNo,omitempty"`
	//是否为主键
	IsPrimaryKey *bool `protobuf:"varint,9,opt,name=isPrimaryKey" json:"isPrimaryKey,omitempty"`
	//是否为空
	IsNullable *bool `protobuf:"varint,10,opt,name=isNullable" json:"isNullable,omitempty"`
	//列编码
	ColEncoding          *string  `protobuf:"bytes,11,opt,name=colEncoding" json:"colEncoding,omitempty"`
	ColDescription       *string  `protobuf:"bytes,12,opt,name=colDescription" json:"colDescription,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ColumnInfo) Reset()         { *m = ColumnInfo{} }
func (m *ColumnInfo) String() string { return proto.CompactTextString(m) }
func (*ColumnInfo) ProtoMessage()    {}
func (*ColumnInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{8}
}
func (m *ColumnInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColumnInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColumnInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnInfo.Merge(m, src)
}
func (m *ColumnInfo) XXX_Size() int {
	return m.Size()
}
func (m *ColumnInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnInfo proto.InternalMessageInfo

func (m *ColumnInfo) GetColName() string {
	if m != nil && m.ColName != nil {
		return *m.ColName
	}
	return ""
}

func (m *ColumnInfo) GetColLen() string {
	if m != nil && m.ColLen != nil {
		return *m.ColLen
	}
	return ""
}

func (m *ColumnInfo) GetDataPrecision() string {
	if m != nil && m.DataPrecision != nil {
		return *m.DataPrecision
	}
	return ""
}

func (m *ColumnInfo) GetDataType() string {
	if m != nil && m.DataType != nil {
		return *m.DataType
	}
	return ""
}

func (m *ColumnInfo) GetColJavaType() string {
	if m != nil && m.ColJavaType != nil {
		return *m.ColJavaType
	}
	return ""
}

func (m *ColumnInfo) GetColumnType() string {
	if m != nil && m.ColumnType != nil {
		return *m.ColumnType
	}
	return ""
}

func (m *ColumnInfo) GetGeneralType() []byte {
	if m != nil {
		return m.GeneralType
	}
	return nil
}

func (m *ColumnInfo) GetOrderNo() int32 {
	if m != nil && m.OrderNo != nil {
		return *m.OrderNo
	}
	return 0
}

func (m *ColumnInfo) GetIsPrimaryKey() bool {
	if m != nil && m.IsPrimaryKey != nil {
		return *m.IsPrimaryKey
	}
	return false
}

func (m *ColumnInfo) GetIsNullable() bool {
	if m != nil && m.IsNullable != nil {
		return *m.IsNullable
	}
	return false
}

func (m *ColumnInfo) GetColEncoding() string {
	if m != nil && m.ColEncoding != nil {
		return *m.ColEncoding
	}
	return ""
}

func (m *ColumnInfo) GetColDescription() string {
	if m != nil && m.ColDescription != nil {
		return *m.ColDescription
	}
	return ""
}

type IndexInfo struct {
	// 列名称
	ColName *string `protobuf:"bytes,1,opt,name=colName" json:"colName,omitempty"`
	//索引名称
	IndexName *string `protobuf:"bytes,2,opt,name=indexName" json:"indexName,omitempty"`
	//索引类型
	IndexType *string `protobuf:"bytes,3,opt,name=indexType" json:"indexType,omitempty"`
	//** 索引标识
	// =3000, unique index
	// =1000, pk index
	// =4000, normal index
	UniqueFlag *int32 `protobuf:"varint,4,opt,name=uniqueFlag" json:"uniqueFlag,omitempty"`
	// 索引编号
	IndexNo *int32 `protobuf:"varint,5,opt,name=indexNo" json:"indexNo,omitempty"`
	// 索引说明
	IndexComment         *string  `protobuf:"bytes,6,opt,name=indexComment" json:"indexComment,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IndexInfo) Reset()         { *m = IndexInfo{} }
func (m *IndexInfo) String() string { return proto.CompactTextString(m) }
func (*IndexInfo) ProtoMessage()    {}
func (*IndexInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{9}
}
func (m *IndexInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexInfo.Merge(m, src)
}
func (m *IndexInfo) XXX_Size() int {
	return m.Size()
}
func (m *IndexInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexInfo.DiscardUnknown(m)
}

var xxx_messageInfo_IndexInfo proto.InternalMessageInfo

func (m *IndexInfo) GetColName() string {
	if m != nil && m.ColName != nil {
		return *m.ColName
	}
	return ""
}

func (m *IndexInfo) GetIndexName() string {
	if m != nil && m.IndexName != nil {
		return *m.IndexName
	}
	return ""
}

func (m *IndexInfo) GetIndexType() string {
	if m != nil && m.IndexType != nil {
		return *m.IndexType
	}
	return ""
}

func (m *IndexInfo) GetUniqueFlag() int32 {
	if m != nil && m.UniqueFlag != nil {
		return *m.UniqueFlag
	}
	return 0
}

func (m *IndexInfo) GetIndexNo() int32 {
	if m != nil && m.IndexNo != nil {
		return *m.IndexNo
	}
	return 0
}

func (m *IndexInfo) GetIndexComment() string {
	if m != nil && m.IndexComment != nil {
		return *m.IndexComment
	}
	return ""
}

//*结束事务的一些信息*
type TransactionEnd struct {
	//*已废弃，请使用header里的executeTime*
	ExecuteTime *int64 `protobuf:"varint,1,opt,name=executeTime" json:"executeTime,omitempty"`
	//*事务号*
	TransactionId *string `protobuf:"bytes,2,opt,name=transactionId" json:"transactionId,omitempty"`
	//*预留扩展*
	Props                []*Pair  `protobuf:"bytes,3,rep,name=props" json:"props,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransactionEnd) Reset()         { *m = TransactionEnd{} }
func (m *TransactionEnd) String() string { return proto.CompactTextString(m) }
func (*TransactionEnd) ProtoMessage()    {}
func (*TransactionEnd) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{10}
}
func (m *TransactionEnd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionEnd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionEnd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionEnd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionEnd.Merge(m, src)
}
func (m *TransactionEnd) XXX_Size() int {
	return m.Size()
}
func (m *TransactionEnd) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionEnd.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionEnd proto.InternalMessageInfo

func (m *TransactionEnd) GetExecuteTime() int64 {
	if m != nil && m.ExecuteTime != nil {
		return *m.ExecuteTime
	}
	return 0
}

func (m *TransactionEnd) GetTransactionId() string {
	if m != nil && m.TransactionId != nil {
		return *m.TransactionId
	}
	return ""
}

func (m *TransactionEnd) GetProps() []*Pair {
	if m != nil {
		return m.Props
	}
	return nil
}

//*预留扩展*
type Pair struct {
	Key                  *string  `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value                *string  `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Pair) Reset()         { *m = Pair{} }
func (m *Pair) String() string { return proto.CompactTextString(m) }
func (*Pair) ProtoMessage()    {}
func (*Pair) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{11}
}
func (m *Pair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pair.Merge(m, src)
}
func (m *Pair) XXX_Size() int {
	return m.Size()
}
func (m *Pair) XXX_DiscardUnknown() {
	xxx_messageInfo_Pair.DiscardUnknown(m)
}

var xxx_messageInfo_Pair proto.InternalMessageInfo

func (m *Pair) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *Pair) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func init() {
	proto.RegisterEnum("dsgpb.EntryType", EntryType_name, EntryType_value)
	proto.RegisterEnum("dsgpb.EventType", EventType_name, EventType_value)
	proto.RegisterEnum("dsgpb.DBType", DBType_name, DBType_value)
	proto.RegisterType((*Entry)(nil), "dsgpb.Entry")
	proto.RegisterType((*Header)(nil), "dsgpb.Header")
	proto.RegisterType((*Column)(nil), "dsgpb.Column")
	proto.RegisterType((*RowData)(nil), "dsgpb.RowData")
	proto.RegisterType((*RowDataList)(nil), "dsgpb.RowDataList")
	proto.RegisterType((*TransactionBegin)(nil), "dsgpb.TransactionBegin")
	proto.RegisterType((*TableInfo)(nil), "dsgpb.TableInfo")
	proto.RegisterType((*PrimaryInfo)(nil), "dsgpb.PrimaryInfo")
	proto.RegisterType((*ColumnInfo)(nil), "dsgpb.ColumnInfo")
	proto.RegisterType((*IndexInfo)(nil), "dsgpb.IndexInfo")
	proto.RegisterType((*TransactionEnd)(nil), "dsgpb.TransactionEnd")
	proto.RegisterType((*Pair)(nil), "dsgpb.Pair")
}

func init() { proto.RegisterFile("EntryProtocol.proto", fileDescriptor_237ce6ff565bd62b) }

var fileDescriptor_237ce6ff565bd62b = []byte{
	// 1389 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0x4f, 0x6f, 0xdb, 0x46,
	0x16, 0x5f, 0x9a, 0xa6, 0x24, 0x3e, 0xc9, 0xca, 0x64, 0x36, 0x08, 0x88, 0x6c, 0x60, 0x68, 0x85,
	0xcd, 0xae, 0x61, 0x2c, 0x8c, 0xdd, 0x34, 0x48, 0xd1, 0x1c, 0x0a, 0xe8, 0x0f, 0x1d, 0xb3, 0x95,
	0x29, 0x65, 0x4c, 0x27, 0xcd, 0xc9, 0xa0, 0xa9, 0x89, 0xcd, 0x96, 0xe2, 0x28, 0x24, 0x65, 0xc7,
	0xe8, 0x67, 0xe8, 0xbd, 0x05, 0xfa, 0x11, 0xda, 0xcf, 0xd0, 0x6b, 0x8f, 0x3d, 0xf5, 0x5c, 0xa4,
	0x87, 0x7e, 0x8d, 0xe2, 0xcd, 0x0c, 0x29, 0x2a, 0x01, 0x72, 0xec, 0x6d, 0x7e, 0xbf, 0x37, 0x6f,
	0xf8, 0xfe, 0xfc, 0xde, 0x0c, 0xe1, 0xef, 0x6e, 0x5a, 0x64, 0x37, 0xb3, 0x4c, 0x14, 0x22, 0x12,
	0xc9, 0xc1, 0x12, 0x17, 0xd4, 0x9a, 0xe7, 0x17, 0xcb, 0xf3, 0xfe, 0x8f, 0x26, 0x58, 0xd2, 0x4c,
	0xef, 0x42, 0x63, 0x95, 0xf3, 0xcc, 0x1b, 0x3b, 0x46, 0xcf, 0xd8, 0xb3, 0x99, 0x46, 0xc8, 0xbf,
	0x4a, 0xc4, 0xb5, 0x37, 0x76, 0xb6, 0x14, 0xaf, 0x10, 0xbd, 0x07, 0xad, 0xbc, 0x08, 0x8b, 0xc3,
	0x24, 0xbc, 0x70, 0xcc, 0x9e, 0xb1, 0xd7, 0x62, 0x15, 0xa6, 0x0e, 0x34, 0xcf, 0xc3, 0x22, 0xba,
	0xf4, 0xc6, 0xce, 0xb6, 0x74, 0x2a, 0x21, 0xed, 0x43, 0x47, 0x2e, 0x47, 0x62, 0x95, 0x16, 0xbe,
	0x70, 0xac, 0x9e, 0xb1, 0x67, 0xb1, 0x0d, 0x8e, 0x3e, 0x80, 0xc6, 0x25, 0x0f, 0xe7, 0x3c, 0x73,
	0x1a, 0x3d, 0x63, 0xaf, 0xfd, 0x70, 0xe7, 0x40, 0xc6, 0x7a, 0x70, 0x24, 0x49, 0xa6, 0x8d, 0xf4,
	0x63, 0xb0, 0x39, 0x46, 0x1e, 0xdc, 0x2c, 0xb9, 0xd3, 0xec, 0x19, 0x7b, 0xdd, 0x87, 0x44, 0xef,
	0x74, 0x4b, 0xfe, 0x49, 0x93, 0x4d, 0x5f, 0x8c, 0x07, 0xc1, 0x80, 0xad, 0xf7, 0xd2, 0x5d, 0x80,
	0xbc, 0x10, 0x19, 0x7f, 0x1e, 0x26, 0x2b, 0xee, 0xb4, 0x7a, 0xc6, 0x5e, 0x87, 0xd5, 0x18, 0xcc,
	0x8c, 0x67, 0x99, 0xc8, 0x8e, 0xf3, 0x0b, 0xc7, 0x96, 0xe1, 0x57, 0x18, 0x7d, 0x8b, 0x4b, 0x3e,
	0x09, 0xf3, 0xc2, 0x5f, 0x2d, 0x1c, 0x90, 0xd1, 0xd7, 0x18, 0x65, 0x8f, 0x73, 0x26, 0xae, 0xd1,
	0xde, 0x2e, 0xed, 0x25, 0x43, 0x3f, 0x05, 0x12, 0xce, 0xe7, 0x71, 0x11, 0x8b, 0x34, 0x4c, 0x5e,
	0xf0, 0xf8, 0xe2, 0xb2, 0x70, 0x3a, 0x32, 0x4b, 0xaa, 0x63, 0x67, 0xe2, 0x7a, 0x1c, 0x16, 0xe1,
	0x24, 0xce, 0x0b, 0xf6, 0xde, 0xde, 0xfe, 0xf7, 0x5b, 0xd0, 0x50, 0x75, 0x90, 0x69, 0x44, 0x97,
	0x7c, 0x11, 0xfa, 0xe1, 0x82, 0xeb, 0xa6, 0xd5, 0x18, 0x7a, 0x1f, 0xec, 0x22, 0x3c, 0x4f, 0xb8,
	0x34, 0xab, 0xde, 0xad, 0x09, 0xfa, 0x18, 0x6c, 0x7e, 0xc5, 0xd3, 0x42, 0x56, 0xcf, 0xdc, 0xac,
	0x5e, 0xc9, 0x3f, 0x69, 0x9c, 0xce, 0xc6, 0x83, 0xc0, 0x65, 0xeb, 0xad, 0x52, 0x0e, 0x71, 0xc2,
	0x7d, 0xa1, 0x3b, 0xab, 0x11, 0xb6, 0x3c, 0x8f, 0x52, 0x2f, 0x7d, 0xa5, 0x7a, 0x6a, 0xb3, 0x12,
	0x62, 0x39, 0xc5, 0xf9, 0x97, 0xca, 0xd4, 0x50, 0xe5, 0x2c, 0xb1, 0xb4, 0x2d, 0x79, 0x56, 0xb5,
	0x10, 0x6d, 0x1a, 0xe3, 0x89, 0x99, 0xb8, 0xce, 0xb1, 0x8e, 0xd8, 0x23, 0x93, 0x95, 0x10, 0x2d,
	0x91, 0x48, 0xa4, 0xc5, 0x56, 0x16, 0x0d, 0xfb, 0x3f, 0x18, 0xd0, 0x18, 0x89, 0x64, 0xb5, 0x48,
	0xe9, 0x1d, 0xb0, 0x22, 0x91, 0xf8, 0x42, 0x56, 0xc6, 0x62, 0x0a, 0x68, 0x57, 0xf9, 0x3d, 0x55,
	0x92, 0x12, 0x6a, 0x8b, 0x2c, 0x96, 0x59, 0x59, 0x64, 0xa9, 0xee, 0x41, 0x2b, 0x12, 0x09, 0x0a,
	0x3b, 0x97, 0x49, 0x5b, 0xac, 0xc2, 0xb4, 0x07, 0xed, 0x48, 0x24, 0x52, 0x37, 0x13, 0x9e, 0x6a,
	0x39, 0xd7, 0x29, 0xed, 0xad, 0xb4, 0xa6, 0xd3, 0x2f, 0x71, 0xff, 0x39, 0x34, 0x75, 0xbb, 0x71,
	0x30, 0x6a, 0x5e, 0xb9, 0x8e, 0x7a, 0x83, 0xa3, 0xff, 0x91, 0x21, 0xae, 0x16, 0x69, 0xee, 0x6c,
	0xf5, 0xcc, 0xda, 0x64, 0xa8, 0x94, 0x59, 0x69, 0xed, 0x7f, 0x02, 0xed, 0x9a, 0x8c, 0xe8, 0x3e,
	0xb4, 0x32, 0x05, 0xf1, 0x5c, 0x74, 0xec, 0x6e, 0x8a, 0x8d, 0x55, 0xf6, 0xfe, 0x77, 0x06, 0x90,
	0x20, 0x0b, 0xd3, 0x3c, 0x8c, 0x50, 0x78, 0x43, 0x7e, 0x11, 0xa7, 0x98, 0x25, 0x7f, 0xc3, 0xa3,
	0x55, 0xc1, 0x83, 0x58, 0x6b, 0xcd, 0x64, 0x75, 0x8a, 0xfe, 0x0b, 0x76, 0x8a, 0xb5, 0x97, 0x37,
	0xd7, 0xd5, 0xdd, 0x24, 0xe9, 0x3f, 0xc1, 0x5a, 0x66, 0x62, 0x99, 0x3b, 0xa6, 0x8c, 0xa2, 0xad,
	0xa3, 0x98, 0x85, 0x71, 0xc6, 0x94, 0x05, 0xcb, 0x55, 0x5c, 0x66, 0x3c, 0x9c, 0x7b, 0x73, 0x59,
	0x6c, 0x93, 0x55, 0xb8, 0xff, 0x87, 0x09, 0x76, 0x80, 0x0a, 0x96, 0xda, 0xf9, 0x07, 0x34, 0xaf,
	0x78, 0x96, 0xc7, 0x22, 0x55, 0xc5, 0x7a, 0x62, 0xfc, 0x9f, 0x95, 0x0c, 0x7d, 0x04, 0x90, 0x8b,
	0x55, 0x16, 0xf1, 0xaa, 0xd5, 0xdd, 0xaa, 0x5a, 0xe3, 0xa1, 0x14, 0xb7, 0x75, 0xfc, 0xf2, 0xe4,
	0xd9, 0x84, 0xd5, 0xf6, 0xbd, 0x33, 0x52, 0xe6, 0x87, 0x47, 0x6a, 0xfb, 0xdd, 0x91, 0x72, 0xa0,
	0x29, 0x81, 0x37, 0x2e, 0x47, 0x40, 0x43, 0x1c, 0x1a, 0x94, 0xbc, 0xaf, 0x06, 0xc0, 0x62, 0x1a,
	0xd1, 0xff, 0xc2, 0x6d, 0xb9, 0x65, 0x74, 0x19, 0x66, 0x61, 0x54, 0xf0, 0xec, 0x84, 0x17, 0x7a,
	0x0e, 0xde, 0x37, 0x60, 0x74, 0x51, 0xc6, 0x43, 0xdd, 0x84, 0x96, 0x8a, 0x6e, 0xcd, 0xd0, 0x7d,
	0x20, 0xd2, 0x69, 0xcc, 0xf3, 0x28, 0x8b, 0x97, 0x58, 0x73, 0x7d, 0x7f, 0xbd, 0xc7, 0xd3, 0xc7,
	0xd0, 0x59, 0x66, 0xf1, 0x22, 0xcc, 0x6e, 0xb0, 0x96, 0xb9, 0x03, 0xb2, 0x21, 0xe5, 0x1d, 0x34,
	0x5b, 0x9b, 0xd8, 0xc6, 0x3e, 0xfa, 0x91, 0xd4, 0xfb, 0x6a, 0x91, 0x2a, 0xb7, 0xb6, 0x74, 0xbb,
	0xbd, 0x21, 0x43, 0xe9, 0x55, 0xdf, 0x45, 0xff, 0x07, 0x10, 0xa7, 0x73, 0xfe, 0x46, 0xf9, 0x74,
	0xa4, 0x4f, 0x79, 0xd9, 0x78, 0xa5, 0x81, 0xd5, 0xf6, 0xf4, 0x3d, 0x68, 0xd7, 0x62, 0xd0, 0x33,
	0xb4, 0x5a, 0xa4, 0x7a, 0x9c, 0xd5, 0x0c, 0x49, 0x2c, 0xab, 0xa2, 0xd6, 0xeb, 0x7b, 0xae, 0xc6,
	0xf4, 0xbf, 0x31, 0x01, 0xd6, 0x81, 0xd5, 0xc7, 0xdc, 0xd8, 0x1c, 0xf3, 0xbb, 0xd0, 0x88, 0x44,
	0x82, 0x53, 0xac, 0x1f, 0x3a, 0x85, 0xe8, 0x03, 0xe8, 0xce, 0xc3, 0x22, 0x3c, 0x5b, 0x66, 0x3c,
	0x8a, 0xa5, 0xdc, 0x94, 0x30, 0x76, 0x90, 0x9d, 0x95, 0x24, 0xc6, 0x88, 0x84, 0xd4, 0x9b, 0x92,
	0x46, 0x85, 0xf5, 0x2d, 0xf1, 0x59, 0x78, 0xa5, 0xcc, 0x4a, 0x1d, 0x75, 0x6a, 0x9d, 0x85, 0xdc,
	0xd0, 0xa8, 0x67, 0x51, 0x9e, 0x70, 0xc1, 0x53, 0x9e, 0x85, 0x49, 0x75, 0x57, 0x76, 0x58, 0x9d,
	0xc2, 0xc4, 0x44, 0x36, 0xe7, 0x99, 0x2f, 0xa4, 0x34, 0x2c, 0x56, 0x42, 0xbc, 0x5a, 0xe2, 0x5c,
	0x97, 0xf3, 0x73, 0x7e, 0x23, 0x35, 0xd1, 0x62, 0x1b, 0x1c, 0x7e, 0x3f, 0xce, 0xfd, 0x55, 0x92,
	0xa0, 0x50, 0xe4, 0xbb, 0xd6, 0x62, 0x35, 0x46, 0x67, 0xe0, 0xa6, 0x91, 0x98, 0xc7, 0xe9, 0x85,
	0x7c, 0xd8, 0x54, 0x06, 0x25, 0x45, 0xff, 0x0d, 0xdd, 0x48, 0x24, 0x75, 0xed, 0x75, 0xe4, 0xa6,
	0x77, 0xd8, 0xfe, 0x4f, 0x06, 0xd8, 0x55, 0xd3, 0x3f, 0xd0, 0x8e, 0xfb, 0x60, 0x4b, 0x41, 0xd4,
	0x9f, 0xaf, 0x8a, 0xa8, 0xac, 0xd5, 0xf3, 0x55, 0x5a, 0xcb, 0x6a, 0xae, 0xd2, 0xf8, 0xf5, 0x8a,
	0xcb, 0xbf, 0x13, 0x75, 0x67, 0xd7, 0x18, 0xfc, 0xaa, 0x3a, 0xaa, 0xfc, 0x01, 0x29, 0xa1, 0xac,
	0x15, 0x2e, 0x47, 0x62, 0xb1, 0xe0, 0x69, 0xa1, 0x3b, 0xb1, 0xc1, 0xf5, 0xbf, 0x86, 0x6e, 0xed,
	0x86, 0x74, 0xd3, 0xf9, 0x5f, 0x78, 0x3f, 0xf6, 0x0f, 0x60, 0x1b, 0x21, 0x25, 0x60, 0x7e, 0xc5,
	0x6f, 0x74, 0xd1, 0x70, 0x89, 0x0f, 0xde, 0x95, 0x7c, 0x65, 0xd4, 0xd1, 0x0a, 0xec, 0xbf, 0x06,
	0xbb, 0xfa, 0x1b, 0xa2, 0x77, 0x80, 0x04, 0x6c, 0xe0, 0x9f, 0x0c, 0x46, 0x81, 0x37, 0xf5, 0x87,
	0xee, 0x53, 0xcf, 0x27, 0x06, 0xdd, 0x01, 0x3b, 0x18, 0x0c, 0x27, 0xae, 0xe7, 0x1f, 0x4e, 0xc9,
	0x16, 0x6d, 0x43, 0xf9, 0xd3, 0x44, 0x4c, 0x7a, 0x0b, 0xda, 0x1a, 0x4c, 0xbc, 0x93, 0x80, 0x6c,
	0x53, 0x0a, 0xdd, 0xda, 0x11, 0xae, 0x3f, 0x26, 0x16, 0x1e, 0x70, 0xe4, 0x0e, 0x58, 0x30, 0x74,
	0x07, 0x01, 0x69, 0xec, 0xff, 0x6a, 0x80, 0x5d, 0xfd, 0x43, 0xd0, 0x2e, 0xc0, 0xe1, 0xe9, 0x64,
	0xe2, 0xf9, 0x27, 0x2e, 0x0b, 0x88, 0x41, 0x01, 0x1a, 0x7a, 0xbd, 0x85, 0x6b, 0xf5, 0x87, 0x41,
	0x4c, 0x5c, 0x8f, 0xdd, 0x89, 0x1b, 0xb8, 0x64, 0xbb, 0xf4, 0xd1, 0xd8, 0x42, 0xdb, 0x88, 0xb9,
	0xb8, 0xaf, 0x41, 0x6d, 0xb0, 0x06, 0x93, 0xc0, 0x65, 0xa4, 0x89, 0x4b, 0x97, 0x0d, 0x4e, 0x5c,
	0xd2, 0xc2, 0xe5, 0xb3, 0x53, 0x97, 0xbd, 0x24, 0x36, 0x6d, 0xc1, 0xf6, 0x98, 0x4d, 0x67, 0x04,
	0x68, 0x07, 0x5a, 0x01, 0x3b, 0xf5, 0x47, 0xe8, 0xd8, 0xc6, 0x43, 0x98, 0xeb, 0x0f, 0x8e, 0x5d,
	0xd2, 0x91, 0x07, 0x7a, 0xfe, 0xd8, 0xfd, 0x82, 0xec, 0xc8, 0x0f, 0xab, 0x75, 0xb7, 0x2a, 0xc5,
	0x19, 0x26, 0x76, 0x0b, 0x21, 0xc6, 0x71, 0x36, 0x9e, 0xbe, 0xf0, 0x09, 0xd9, 0x8f, 0xa0, 0xa1,
	0xde, 0x0e, 0xf4, 0x99, 0xb2, 0xc1, 0x68, 0xe2, 0x12, 0x03, 0x3f, 0x2d, 0x5f, 0x12, 0xb2, 0x85,
	0xcb, 0xd9, 0x53, 0x5c, 0x9a, 0xf8, 0xed, 0xe9, 0xf0, 0x4c, 0x19, 0xb6, 0xf1, 0xa0, 0xe9, 0xf0,
	0x4c, 0xbb, 0x58, 0xb4, 0x09, 0xe6, 0xf1, 0x6c, 0x46, 0x1a, 0x18, 0xeb, 0x51, 0x10, 0xcc, 0x48,
	0x13, 0xa9, 0xc3, 0x60, 0x46, 0x5a, 0xc3, 0x47, 0x3f, 0xbf, 0xdd, 0x35, 0x7e, 0x79, 0xbb, 0x6b,
	0xfc, 0xf6, 0x76, 0xd7, 0xf8, 0xf6, 0xf7, 0xdd, 0xbf, 0x01, 0x89, 0xc4, 0x02, 0x95, 0xa0, 0xfe,
	0xdc, 0x23, 0x91, 0x0c, 0xbb, 0xa3, 0x30, 0x0d, 0x13, 0x7c, 0xb0, 0x65, 0x6f, 0x8f, 0x8c, 0x3f,
	0x03, 0x00, 0x00, 0xff, 0xff, 0x73, 0x03, 0x4c, 0xcc, 0xe4, 0x0b, 0x00, 0x00,
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AdditionalWeight != nil {
		{
			size, err := m.AdditionalWeight.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEntryProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.ThisRowNum != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.ThisRowNum))
		i--
		dAtA[i] = 0x58
	}
	if m.TheLastNum != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.TheLastNum))
		i--
		dAtA[i] = 0x50
	}
	if m.ErrorMsg != nil {
		i -= len(*m.ErrorMsg)
		copy(dAtA[i:], *m.ErrorMsg)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.ErrorMsg)))
		i--
		dAtA[i] = 0x4a
	}
	if m.StoreValue != nil {
		i -= len(m.StoreValue)
		copy(dAtA[i:], m.StoreValue)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(m.StoreValue)))
		i--
		dAtA[i] = 0x42
	}
	if m.EntryType != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.EntryType))
		i--
		dAtA[i] = 0x38
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEntryProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.BatchCountNo != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.BatchCountNo))
		i--
		dAtA[i] = 0x28
	}
	if m.BatchID != nil {
		i -= len(*m.BatchID)
		copy(dAtA[i:], *m.BatchID)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.BatchID)))
		i--
		dAtA[i] = 0x22
	}
	if m.StatFlag != nil {
		i--
		if *m.StatFlag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.FlowID != nil {
		i -= len(*m.FlowID)
		copy(dAtA[i:], *m.FlowID)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.FlowID)))
		i--
		dAtA[i] = 0x12
	}
	if m.UserID != nil {
		i -= len(*m.UserID)
		copy(dAtA[i:], *m.UserID)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.UserID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ColsNum != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.ColsNum))
		i--
		dAtA[i] = 0x48
	}
	if m.RowsNum != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.RowsNum))
		i--
		dAtA[i] = 0x40
	}
	if m.OperType != nil {
		i -= len(*m.OperType)
		copy(dAtA[i:], *m.OperType)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.OperType)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ObjnInfo != nil {
		i -= len(*m.ObjnInfo)
		copy(dAtA[i:], *m.ObjnInfo)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.ObjnInfo)))
		i--
		dAtA[i] = 0x32
	}
	if m.ScnInfo != nil {
		i -= len(*m.ScnInfo)
		copy(dAtA[i:], *m.ScnInfo)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.ScnInfo)))
		i--
		dAtA[i] = 0x2a
	}
	if m.FileNo != nil {
		i -= len(*m.FileNo)
		copy(dAtA[i:], *m.FileNo)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.FileNo)))
		i--
		dAtA[i] = 0x22
	}
	if m.EventType != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.EventType))
		i--
		dAtA[i] = 0x18
	}
	if m.TableName != nil {
		i -= len(*m.TableName)
		copy(dAtA[i:], *m.TableName)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if m.SchemaName != nil {
		i -= len(*m.SchemaName)
		copy(dAtA[i:], *m.SchemaName)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.SchemaName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Column) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ColValue != nil {
		i -= len(*m.ColValue)
		copy(dAtA[i:], *m.ColValue)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.ColValue)))
		i--
		dAtA[i] = 0x32
	}
	if m.ColValueLen != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.ColValueLen))
		i--
		dAtA[i] = 0x28
	}
	if m.ColFlags != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.ColFlags))
		i--
		dAtA[i] = 0x20
	}
	if m.ColName != nil {
		i -= len(*m.ColName)
		copy(dAtA[i:], *m.ColName)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.ColName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ColType != nil {
		i -= len(*m.ColType)
		copy(dAtA[i:], *m.ColType)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.ColType)))
		i--
		dAtA[i] = 0x12
	}
	if m.ColNo != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.ColNo))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RowData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEntryProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ColValueLens != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.ColValueLens))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RowDataList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowDataList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowDataList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RowDatas) > 0 {
		for iNdEx := len(m.RowDatas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RowDatas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEntryProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TransactionBegin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionBegin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionBegin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ThreadId != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.ThreadId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Props) > 0 {
		for iNdEx := len(m.Props) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Props[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEntryProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.TransactionId != nil {
		i -= len(*m.TransactionId)
		copy(dAtA[i:], *m.TransactionId)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.TransactionId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ExecuteTime != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.ExecuteTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexInfos) > 0 {
		for iNdEx := len(m.IndexInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IndexInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEntryProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.ColumnInfos) > 0 {
		for iNdEx := len(m.ColumnInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ColumnInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEntryProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.PrimaryInfos) > 0 {
		for iNdEx := len(m.PrimaryInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PrimaryInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEntryProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.TableDescription != nil {
		i -= len(*m.TableDescription)
		copy(dAtA[i:], *m.TableDescription)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.TableDescription)))
		i--
		dAtA[i] = 0x4a
	}
	if m.CreateTime != nil {
		i -= len(*m.CreateTime)
		copy(dAtA[i:], *m.CreateTime)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.CreateTime)))
		i--
		dAtA[i] = 0x42
	}
	if m.TableCharacterSet != nil {
		i -= len(*m.TableCharacterSet)
		copy(dAtA[i:], *m.TableCharacterSet)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.TableCharacterSet)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ObjnNo != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.ObjnNo))
		i--
		dAtA[i] = 0x30
	}
	if m.TableID != nil {
		i -= len(*m.TableID)
		copy(dAtA[i:], *m.TableID)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.TableID)))
		i--
		dAtA[i] = 0x2a
	}
	if m.TableName != nil {
		i -= len(*m.TableName)
		copy(dAtA[i:], *m.TableName)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.TableName)))
		i--
		dAtA[i] = 0x22
	}
	if m.SchemaName != nil {
		i -= len(*m.SchemaName)
		copy(dAtA[i:], *m.SchemaName)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.SchemaName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SourceType != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.SourceType))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrimaryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimaryInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrimaryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ColumnName != nil {
		i -= len(*m.ColumnName)
		copy(dAtA[i:], *m.ColumnName)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.ColumnName)))
		i--
		dAtA[i] = 0x12
	}
	if m.ColumnNo != nil {
		i -= len(*m.ColumnNo)
		copy(dAtA[i:], *m.ColumnNo)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.ColumnNo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ColumnInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ColDescription != nil {
		i -= len(*m.ColDescription)
		copy(dAtA[i:], *m.ColDescription)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.ColDescription)))
		i--
		dAtA[i] = 0x62
	}
	if m.ColEncoding != nil {
		i -= len(*m.ColEncoding)
		copy(dAtA[i:], *m.ColEncoding)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.ColEncoding)))
		i--
		dAtA[i] = 0x5a
	}
	if m.IsNullable != nil {
		i--
		if *m.IsNullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.IsPrimaryKey != nil {
		i--
		if *m.IsPrimaryKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.OrderNo != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.OrderNo))
		i--
		dAtA[i] = 0x40
	}
	if m.GeneralType != nil {
		i -= len(m.GeneralType)
		copy(dAtA[i:], m.GeneralType)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(m.GeneralType)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ColumnType != nil {
		i -= len(*m.ColumnType)
		copy(dAtA[i:], *m.ColumnType)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.ColumnType)))
		i--
		dAtA[i] = 0x32
	}
	if m.ColJavaType != nil {
		i -= len(*m.ColJavaType)
		copy(dAtA[i:], *m.ColJavaType)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.ColJavaType)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DataType != nil {
		i -= len(*m.DataType)
		copy(dAtA[i:], *m.DataType)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.DataType)))
		i--
		dAtA[i] = 0x22
	}
	if m.DataPrecision != nil {
		i -= len(*m.DataPrecision)
		copy(dAtA[i:], *m.DataPrecision)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.DataPrecision)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ColLen != nil {
		i -= len(*m.ColLen)
		copy(dAtA[i:], *m.ColLen)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.ColLen)))
		i--
		dAtA[i] = 0x12
	}
	if m.ColName != nil {
		i -= len(*m.ColName)
		copy(dAtA[i:], *m.ColName)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.ColName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IndexInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IndexComment != nil {
		i -= len(*m.IndexComment)
		copy(dAtA[i:], *m.IndexComment)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.IndexComment)))
		i--
		dAtA[i] = 0x32
	}
	if m.IndexNo != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.IndexNo))
		i--
		dAtA[i] = 0x28
	}
	if m.UniqueFlag != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.UniqueFlag))
		i--
		dAtA[i] = 0x20
	}
	if m.IndexType != nil {
		i -= len(*m.IndexType)
		copy(dAtA[i:], *m.IndexType)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.IndexType)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexName != nil {
		i -= len(*m.IndexName)
		copy(dAtA[i:], *m.IndexName)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.IndexName)))
		i--
		dAtA[i] = 0x12
	}
	if m.ColName != nil {
		i -= len(*m.ColName)
		copy(dAtA[i:], *m.ColName)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.ColName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransactionEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionEnd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionEnd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Props) > 0 {
		for iNdEx := len(m.Props) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Props[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEntryProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.TransactionId != nil {
		i -= len(*m.TransactionId)
		copy(dAtA[i:], *m.TransactionId)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.TransactionId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ExecuteTime != nil {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(*m.ExecuteTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Pair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != nil {
		i -= len(*m.Value)
		copy(dAtA[i:], *m.Value)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != nil {
		i -= len(*m.Key)
		copy(dAtA[i:], *m.Key)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(*m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEntryProtocol(dAtA []byte, offset int, v uint64) int {
	offset -= sovEntryProtocol(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Entry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != nil {
		l = len(*m.UserID)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.FlowID != nil {
		l = len(*m.FlowID)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.StatFlag != nil {
		n += 2
	}
	if m.BatchID != nil {
		l = len(*m.BatchID)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.BatchCountNo != nil {
		n += 1 + sovEntryProtocol(uint64(*m.BatchCountNo))
	}
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.EntryType != nil {
		n += 1 + sovEntryProtocol(uint64(*m.EntryType))
	}
	if m.StoreValue != nil {
		l = len(m.StoreValue)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.ErrorMsg != nil {
		l = len(*m.ErrorMsg)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.TheLastNum != nil {
		n += 1 + sovEntryProtocol(uint64(*m.TheLastNum))
	}
	if m.ThisRowNum != nil {
		n += 1 + sovEntryProtocol(uint64(*m.ThisRowNum))
	}
	if m.AdditionalWeight != nil {
		l = m.AdditionalWeight.Size()
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaName != nil {
		l = len(*m.SchemaName)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.TableName != nil {
		l = len(*m.TableName)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.EventType != nil {
		n += 1 + sovEntryProtocol(uint64(*m.EventType))
	}
	if m.FileNo != nil {
		l = len(*m.FileNo)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.ScnInfo != nil {
		l = len(*m.ScnInfo)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.ObjnInfo != nil {
		l = len(*m.ObjnInfo)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.OperType != nil {
		l = len(*m.OperType)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.RowsNum != nil {
		n += 1 + sovEntryProtocol(uint64(*m.RowsNum))
	}
	if m.ColsNum != nil {
		n += 1 + sovEntryProtocol(uint64(*m.ColsNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColNo != nil {
		n += 1 + sovEntryProtocol(uint64(*m.ColNo))
	}
	if m.ColType != nil {
		l = len(*m.ColType)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.ColName != nil {
		l = len(*m.ColName)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.ColFlags != nil {
		n += 1 + sovEntryProtocol(uint64(*m.ColFlags))
	}
	if m.ColValueLen != nil {
		n += 1 + sovEntryProtocol(uint64(*m.ColValueLen))
	}
	if m.ColValue != nil {
		l = len(*m.ColValue)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RowData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColValueLens != nil {
		n += 1 + sovEntryProtocol(uint64(*m.ColValueLens))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovEntryProtocol(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RowDataList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RowDatas) > 0 {
		for _, e := range m.RowDatas {
			l = e.Size()
			n += 1 + l + sovEntryProtocol(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransactionBegin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExecuteTime != nil {
		n += 1 + sovEntryProtocol(uint64(*m.ExecuteTime))
	}
	if m.TransactionId != nil {
		l = len(*m.TransactionId)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if len(m.Props) > 0 {
		for _, e := range m.Props {
			l = e.Size()
			n += 1 + l + sovEntryProtocol(uint64(l))
		}
	}
	if m.ThreadId != nil {
		n += 1 + sovEntryProtocol(uint64(*m.ThreadId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		n += 1 + sovEntryProtocol(uint64(*m.Version))
	}
	if m.SourceType != nil {
		n += 1 + sovEntryProtocol(uint64(*m.SourceType))
	}
	if m.SchemaName != nil {
		l = len(*m.SchemaName)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.TableName != nil {
		l = len(*m.TableName)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.TableID != nil {
		l = len(*m.TableID)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.ObjnNo != nil {
		n += 1 + sovEntryProtocol(uint64(*m.ObjnNo))
	}
	if m.TableCharacterSet != nil {
		l = len(*m.TableCharacterSet)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.CreateTime != nil {
		l = len(*m.CreateTime)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.TableDescription != nil {
		l = len(*m.TableDescription)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if len(m.PrimaryInfos) > 0 {
		for _, e := range m.PrimaryInfos {
			l = e.Size()
			n += 1 + l + sovEntryProtocol(uint64(l))
		}
	}
	if len(m.ColumnInfos) > 0 {
		for _, e := range m.ColumnInfos {
			l = e.Size()
			n += 1 + l + sovEntryProtocol(uint64(l))
		}
	}
	if len(m.IndexInfos) > 0 {
		for _, e := range m.IndexInfos {
			l = e.Size()
			n += 1 + l + sovEntryProtocol(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrimaryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnNo != nil {
		l = len(*m.ColumnNo)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.ColumnName != nil {
		l = len(*m.ColumnName)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColumnInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColName != nil {
		l = len(*m.ColName)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.ColLen != nil {
		l = len(*m.ColLen)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.DataPrecision != nil {
		l = len(*m.DataPrecision)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.DataType != nil {
		l = len(*m.DataType)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.ColJavaType != nil {
		l = len(*m.ColJavaType)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.ColumnType != nil {
		l = len(*m.ColumnType)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.GeneralType != nil {
		l = len(m.GeneralType)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.OrderNo != nil {
		n += 1 + sovEntryProtocol(uint64(*m.OrderNo))
	}
	if m.IsPrimaryKey != nil {
		n += 2
	}
	if m.IsNullable != nil {
		n += 2
	}
	if m.ColEncoding != nil {
		l = len(*m.ColEncoding)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.ColDescription != nil {
		l = len(*m.ColDescription)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IndexInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColName != nil {
		l = len(*m.ColName)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.IndexName != nil {
		l = len(*m.IndexName)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.IndexType != nil {
		l = len(*m.IndexType)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.UniqueFlag != nil {
		n += 1 + sovEntryProtocol(uint64(*m.UniqueFlag))
	}
	if m.IndexNo != nil {
		n += 1 + sovEntryProtocol(uint64(*m.IndexNo))
	}
	if m.IndexComment != nil {
		l = len(*m.IndexComment)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransactionEnd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExecuteTime != nil {
		n += 1 + sovEntryProtocol(uint64(*m.ExecuteTime))
	}
	if m.TransactionId != nil {
		l = len(*m.TransactionId)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if len(m.Props) > 0 {
		for _, e := range m.Props {
			l = e.Size()
			n += 1 + l + sovEntryProtocol(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Pair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovEntryProtocol(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEntryProtocol(x uint64) (n int) {
	return sovEntryProtocol(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.UserID = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FlowID = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatFlag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.StatFlag = &b
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BatchID = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCountNo", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BatchCountNo = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryType", wireType)
			}
			var v EntryType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= EntryType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EntryType = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreValue = append(m.StoreValue[:0], dAtA[iNdEx:postIndex]...)
			if m.StoreValue == nil {
				m.StoreValue = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ErrorMsg = &s
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TheLastNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TheLastNum = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThisRowNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ThisRowNum = &v
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalWeight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdditionalWeight == nil {
				m.AdditionalWeight = &RowDataList{}
			}
			if err := m.AdditionalWeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SchemaName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TableName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			var v EventType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= EventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EventType = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FileNo = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScnInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ScnInfo = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjnInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ObjnInfo = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OperType = &s
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsNum", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RowsNum = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColsNum", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ColsNum = &v
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColNo", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ColNo = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ColType = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ColName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColFlags", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ColFlags = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColValueLen", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ColValueLen = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ColValue = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColValueLens", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ColValueLens = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowDataList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowDataList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowDataList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowDatas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RowDatas = append(m.RowDatas, &RowData{})
			if err := m.RowDatas[len(m.RowDatas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionBegin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionBegin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionBegin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecuteTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExecuteTime = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TransactionId = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Props = append(m.Props, &Pair{})
			if err := m.Props[len(m.Props)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ThreadId = &v
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Version = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceType", wireType)
			}
			var v DBType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= DBType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SourceType = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SchemaName = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TableName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TableID = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjnNo", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ObjnNo = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableCharacterSet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TableCharacterSet = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CreateTime = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TableDescription = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryInfos = append(m.PrimaryInfos, &PrimaryInfo{})
			if err := m.PrimaryInfos[len(m.PrimaryInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnInfos = append(m.ColumnInfos, &ColumnInfo{})
			if err := m.ColumnInfos[len(m.ColumnInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexInfos = append(m.IndexInfos, &IndexInfo{})
			if err := m.IndexInfos[len(m.IndexInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimaryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimaryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimaryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ColumnNo = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ColumnName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ColName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColLen", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ColLen = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataPrecision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DataPrecision = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DataType = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColJavaType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ColJavaType = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ColumnType = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneralType", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeneralType = append(m.GeneralType[:0], dAtA[iNdEx:postIndex]...)
			if m.GeneralType == nil {
				m.GeneralType = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderNo", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OrderNo = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimaryKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsPrimaryKey = &b
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsNullable = &b
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColEncoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ColEncoding = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ColDescription = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ColName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IndexName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IndexType = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueFlag", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UniqueFlag = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexNo", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IndexNo = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexComment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IndexComment = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionEnd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionEnd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecuteTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExecuteTime = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TransactionId = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Props = append(m.Props, &Pair{})
			if err := m.Props[len(m.Props)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEntryProtocol(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEntryProtocol
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEntryProtocol
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEntryProtocol
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEntryProtocol        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEntryProtocol          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEntryProtocol = fmt.Errorf("proto: unexpected end of group")
)
